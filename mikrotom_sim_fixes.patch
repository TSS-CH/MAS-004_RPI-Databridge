--- /mnt/data/mik_orig/Mikrotom-Simulator/mikrotom_sim.py	2026-02-05 17:36:08.000000000 +0000
+++ /mnt/data/mik/Mikrotom-Simulator/mikrotom_sim.py	2026-02-06 12:58:31.276784939 +0000
@@ -1,133 +1,142 @@
-import argparse
-import threading
-import time
-from datetime import datetime
-from queue import Queue
-
-import requests
-import urllib3
-from fastapi import FastAPI, Request
-import uvicorn
-from pathlib import Path
-
-
-def ts():
-    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
-
-
-def log(msg):
-    print(f"[{ts()}] {msg}", flush=True)
-
-
-app = FastAPI(title="MikrotomSim", version="0.2.0")
-
-inbox_q: "Queue[dict]" = Queue()
-_id = 0
-_id_lock = threading.Lock()
-
-
-@app.get("/health")
-def health():
-    return {"ok": True}
-
-
-@app.post("/api/inbox")
-async def api_inbox(request: Request):
-    global _id
-    body = None
-    try:
-        body = await request.json()
-    except Exception:
-        body = None
-
-    with _id_lock:
-        _id += 1
-        mid = _id
-
-    msg = {"id": mid, "body": body, "source": (request.client.host if request.client else None)}
-    inbox_q.put(msg)
-
-    log(f"RECV from Raspi -> MikrotomSim  id={mid} body={body}")
-    return {"ok": True, "stored": True, "id": mid}
-
-
-def sender_loop(raspi_url: str, verify_tls: bool):
-    while True:
-        try:
-            cmd = input("> ").strip()
-        except EOFError:
-            break
-        if not cmd:
-            continue
-        if cmd.lower() in ("quit", "exit"):
-            break
-
-        idem = f"mikrotom-sim-{int(time.time()*1000)}"
-        payload = {"cmd": cmd, "ts": time.time()}
-        headers = {"X-Idempotency-Key": idem}
-
-        try:
-            resp = requests.post(
-                raspi_url.rstrip("/") + "/api/inbox",
-                json=payload,
-                headers=headers,
-                timeout=5,
-                verify=verify_tls,
-            )
-            log(f"SEND MikrotomSim -> Raspi  body={payload}  resp={resp.text}")
-        except Exception as e:
-            log(f"SEND FAIL -> Raspi err={repr(e)}")
-
-
-def _to_abs_path(p: str) -> str:
-    """Relative Pfade relativ zum Script-Ordner interpretieren."""
-    if not p:
-        return p
-    pp = Path(p)
-    if pp.is_absolute():
-        return str(pp)
-    return str((Path(__file__).resolve().parent / pp).resolve())
-
-
-def main():
-    ap = argparse.ArgumentParser()
-    ap.add_argument("--host", default="0.0.0.0")
-    ap.add_argument("--port", type=int, default=9090)
-
-    ap.add_argument("--raspi", default="https://192.168.1.100:8080")
-    ap.add_argument("--verify", action="store_true", help="verify TLS certs (default: off for self-signed)")
-
-    # HTTPS für MikrotomSim selbst
-    ap.add_argument("--https", action="store_true", help="serve MikrotomSim via HTTPS")
-
-    # akzeptiere BEIDE Varianten, damit du nicht mehr stolperst:
-    ap.add_argument("--certfile", dest="certfile", default="certs/mikrotom.crt")
-    ap.add_argument("--keyfile", dest="keyfile", default="certs/mikrotom.key")
-
-    # (optional alte Namen)
-    ap.add_argument("--cert", dest="certfile")
-    ap.add_argument("--key", dest="keyfile")
-
-    args = ap.parse_args()
-
-    if not args.verify:
-        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
-
-    t = threading.Thread(target=sender_loop, args=(args.raspi, args.verify), daemon=True)
-    t.start()
-
-    scheme = "https" if args.https else "http"
-    log("Type a command and press Enter. Example: TTP00002=?  or  MAS0026=20")
-    log(f"MikrotomSim listening on {scheme}://{args.host}:{args.port}")
-
-    ssl_kwargs = {}
-    if args.https:
-        cert = _to_abs_path(args.certfile)
-        key = _to_abs_path(args.keyfile)
-        ssl_kwargs = {"ssl_certfile": cert, "ssl_keyfile": key}
-
-    uvicorn.run(app, host=args.host, port=args.port, log_level="info", **ssl_kwargs)
-
-
-if __name__ == "__main__":
-    main()
+import argparse
+import threading
+import time
+from datetime import datetime
+from queue import Queue
+
+import requests
+import urllib3
+from fastapi import FastAPI, Request
+import uvicorn
+from pathlib import Path
+
+
+def ts():
+    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
+
+
+def log(msg):
+    print(f"[{ts()}] {msg}", flush=True)
+
+
+app = FastAPI(title="MikrotomSim", version="0.2.0")
+
+inbox_q: "Queue[dict]" = Queue()
+_id = 0
+_id_lock = threading.Lock()
+
+
+@app.get("/health")
+def health():
+    return {"ok": True}
+
+
+@app.post("/api/inbox")
+async def api_inbox(request: Request):
+    global _id
+    body = None
+    try:
+        body = await request.json()
+    except Exception:
+        body = None
+
+    with _id_lock:
+        _id += 1
+        mid = _id
+
+    msg = {"id": mid, "body": body, "source": (request.client.host if request.client else None)}
+    inbox_q.put(msg)
+
+    log(f"RECV from Raspi -> MikrotomSim  id={mid} body={body}")
+    return {"ok": True, "stored": True, "id": mid}
+
+
+def sender_loop(raspi_url: str, verify_tls: bool, shared_secret: str):
+    while True:
+        try:
+            cmd = input("> ").strip()
+        except EOFError:
+            break
+        if not cmd:
+            continue
+        if cmd.lower() in ("quit", "exit"):
+            break
+
+        idem = f"mikrotom-sim-{int(time.time()*1000)}"
+        payload = {"cmd": cmd, "ts": time.time()}
+        headers = {"X-Idempotency-Key": idem}
+        if shared_secret:
+            headers["X-Shared-Secret"] = shared_secret
+
+        try:
+            resp = requests.post(
+                raspi_url.rstrip("/") + "/api/inbox",
+                json=payload,
+                headers=headers,
+                timeout=5,
+                verify=verify_tls,
+            )
+            log(f"SEND MikrotomSim -> Raspi  body={payload}  resp={resp.text}")
+        except Exception as e:
+            log(f"SEND FAIL -> Raspi err={repr(e)}")
+
+
+def _to_abs_path(p: str) -> str:
+    """Relative Pfade relativ zum Script-Ordner interpretieren."""
+    if not p:
+        return p
+    pp = Path(p)
+    if pp.is_absolute():
+        return str(pp)
+    return str((Path(__file__).resolve().parent / pp).resolve())
+
+
+def main():
+    ap = argparse.ArgumentParser()
+    ap.add_argument("--host", default="0.0.0.0")
+    ap.add_argument("--port", type=int, default=9090)
+
+    ap.add_argument("--raspi", default="https://192.168.1.100:8080")
+    ap.add_argument("--shared-secret", default="", help="shared secret for Raspi /api/inbox (X-Shared-Secret)")
+    ap.add_argument("--shared-secret-env", default="MAS004_SHARED_SECRET", help="environment variable name to read shared secret from (optional)")
+    ap.add_argument("--verify", action="store_true", help="verify TLS certs (default: off for self-signed)")
+
+    # HTTPS für MikrotomSim selbst
+    ap.add_argument("--https", action="store_true", help="serve MikrotomSim via HTTPS")
+
+    # akzeptiere BEIDE Varianten, damit du nicht mehr stolperst:
+    ap.add_argument("--certfile", dest="certfile", default="certs/mikrotom.crt")
+    ap.add_argument("--keyfile", dest="keyfile", default="certs/mikrotom.key")
+
+    # (optional alte Namen)
+    ap.add_argument("--cert", dest="certfile")
+    ap.add_argument("--key", dest="keyfile")
+
+    args = ap.parse_args()
+
+    # shared secret can be provided as --shared-secret or via env var
+    if not args.shared_secret and args.shared_secret_env:
+        import os
+        args.shared_secret = os.getenv(args.shared_secret_env, "")
+
+    if not args.verify:
+        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
+
+    t = threading.Thread(target=sender_loop, args=(args.raspi, args.verify, args.shared_secret), daemon=True)
+    t.start()
+
+    scheme = "https" if args.https else "http"
+    log("Type a command and press Enter. Example: TTP00002=?  or  MAS0026=20")
+    log(f"MikrotomSim listening on {scheme}://{args.host}:{args.port}")
+
+    ssl_kwargs = {}
+    if args.https:
+        cert = _to_abs_path(args.certfile)
+        key = _to_abs_path(args.keyfile)
+        ssl_kwargs = {"ssl_certfile": cert, "ssl_keyfile": key}
+
+    uvicorn.run(app, host=args.host, port=args.port, log_level="info", access_log=False, **ssl_kwargs)
+
+
+if __name__ == "__main__":
+    main()
